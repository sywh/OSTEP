# 第4章 抽象：进程
- 操作系统通过一些低级机制和高级策略来实现CPU虚拟化：让一个进程只运行一个时间片，然后切换到其它进程，来提供存在多个虚拟CPU的假象
- 机制为how问题提供答案，例如，操作系统如何执行上下文切换；策略为which问题提供答案，例如，操作系统现在应该运行哪个进程
- 进程包括机器状态（可以访问的内存、寄存器、持久存储设备）、进程状态（运行/就绪/阻塞/僵尸）等信息
- 操作系统将程序转化为进程，需要做以下几点
  - 将代码和所有静态数据（例如初始化变量）加载到内存中，加载到进程的地址空间中
  - 创建和初始化栈，为程序的运行时栈分配一些内存，存放局部变量、函数参数和返回地址
  - 为程序的堆分配一些内存，数据结构（如链表、散列表、树和其它有趣的数据结构）需要堆
  - 初始化I/O相关的任务，每个进程都有3个打开的文件描述符，用于标准输入、输出和错误
  - 启动程序，在入口处运行，即main()，OS将CPU的控制权转移到新创建的进程中，从而程序开始执行
# 第5章 插叙：进程API
- fork()和exec()组合在创建和操作进程时非常强大，shell本身，输出重定向和管道(使用pipe()系统调用)都是基于该组合实现的
- fork()和wait()组合，能让父进程等待子进程完成，使输出结果变得确定
# 第6章 机制：受限直接运行
- 虚拟化CPU时，希望在保留操作系统对CPU的控制权的同时，获得高性能，该技术称为受限（对应控制权）直接运行（对应高性能）
- 硬件通过提供用户模式、内核模式两种不同的执行模式来协助操作系统实现受限直接运行。用户程序一般运行在用户模式下，当希望执行某种特权操作时，硬件提供用户程序执行**系统调用**的能力，通过特殊的陷阱指令，跳入内核并将特权级别提升到内核模式来执行特权操作。完成后，操作系统调用从陷阱返回指令，回到发起调用的用户程序中，同时将特权级别降低，回到用户模式
- 在执行陷阱时，硬件需要确保存储足够的调用者寄存器，以便在操作系统发出从陷阱返回指令时能正确返回。在x86上，处理器会将程序计数器、标志和其他一些寄存器推送到每个进程的**内核栈**上。从陷阱返回时将从栈弹出这些值，并恢复执行用户模式程序
- 内核在启动时设置**陷阱表**，来告诉硬件在发生系统调用和其他异常事件时要运行哪些代码，指定要跳转到的地址
- 操作系统可通过等待系统调用、某种非法操作发生或者时钟中断来重新获得CPU的控制权。与系统调用类似，操作系统也必须通知硬件哪些代码在发生时钟中断时运行
- 操作系统在重新获得控制权后，可能会进行**上下文切换**，主要是切换内核栈，设计到两种类型的寄存器保存/恢复。第一种是发生时钟中断的时候，运行进程的用户寄存器由硬件隐式保存到该进程的内核栈；第二种是操作系统决定从A切换到B，内核寄存器被操作系统明确地保存到该进程的进程结构的内存中。目前个人理解是进程结构包括内核栈指针，可以从内核栈中恢复寄存器即进程上下文。操作系统通过切换进程结构来切换内核栈，进而在从陷阱返回时，从内核栈中恢复寄存器即切换进程上下文，从而实现进程切换。
- 现代处理器上，系统调用和上下文切换的性能可以达到亚微妙级，实现了高性能
# 第7章 进程调度：介绍
- 在不同工作负载假设时，会得到不同的最优调度策略。因此，确定工作负载是构建调度策略的关键部分。工作负载了解得越多，你的策略就越优化。最理想的负载假设包括
  - 每一个工作运行相同的时间
  - 所有的工作同时到达
  - 一旦开始，每个工作保持运行直到完成
  - 所有的工作只是用CPU（即他们不执行IO操作）
  - 每个工作的运行时间是已知的
- 通过调度指标来比较不同的调度策略，常用的调度指标包括周转时间和响应时间。周转时间反映性能；响应时间可以反映系统的交互性能，反映公平。性能和公平在调度系统中往往是矛盾的
- SJF/STCF优化周转时间，RR优化响应时间
- 摊销可以减少成本，重叠可以提供利用率
# 第8章 调度：多级反馈队列
- MLFQ中有许多独立的队列，每个队列有不同的优先级。MLFQ总是优先执行较高优先级的工作（即在较高级队列中的工作）；同一个队列中的工作采用轮转调度。因此，MLFQ调度策略的关键在于如何设置优先级
- MLFQ根据观察到的工作的行为调整它的优先级
- MLFQ的基本规则
  - 规则1：如果A的优先级 > B的优先级，运行A
  - 规则2：如果A的优先级 = B的优先级，轮转运行A和B
  - 规则3：工作进入系统时，放在最高优先级（最上层队列）
  - 规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）
  - 规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列
# 第9章 调度：比例份额
- 比例份额是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间
- 彩票调度最精彩的地方在于利用了随机性。当你需要做出决定时，采用随机的方式常常是既可靠又简单的选择
- 步长调度选择目前拥有最小行程值的进程，并且在运行之后将该进程的行程值增加一个步长
- 彩票调度算法只能运行一段时间后，在概率上实现比例，而步长调度算法可以在每个调度周期后做到完全正确
- 彩票调度算法相比步长调度算法，不需要全局状态，能够更合理地处理新加入的进程
# 第10章 多处理器调度
# 第13章 抽象：地址空间
- 一种实现时分共享的方法，是让一个进程单独占用全部内存运行一小段时间，然后停止它，并将它所有的状态信息保存在磁盘上
- 将全部的内存信息保存到磁盘太慢了，因此，在进程切换的时候，我们仍然将进程信息放在内存中。多个程序同时驻留在内存中，使保护成为重要问题
- 当我们描述地址空间时，所描述的是操作系统提供给运行程序的抽象。操作系统在专门硬件的帮助下，通过每一个虚拟内存的索引，将其转换为物理地址。作为用户级程序的程序员，可以看到的任何地址都是虚拟地址，只有操作系统和硬件才知道物理地址
# 第14章 插叙：内存操作API
# 第15章 机制：地址转换
# 第16章 分段
# 第17章 空闲空间管理
# 第18章 分页：介绍
# 第19章 分页：快速地址转换（TLB）
# 第20章 分页：较小的表
# 第21章 超越物理内存：机制
# 第22章 超越物理内存：策略
# 第23章 VAX/VMS虚拟内存系统
# 第26章 并发：介绍
# 第27章 插叙：线程API
# 第28章 锁
# 第29章 基于锁的并发数据结构
# 第30章 条件变量
# 第31章 信号量
# 第32章 常见并发问题
# 第33章 基于事件的并发
# 第36章 I/O设备
# 第37章 磁盘驱动器
# 第38章 廉价冗余磁盘阵列（RAID）
# 第39章 插叙：文件和目录
# 第40章 文件系统实现
# 第41章 局部性和快速文件系统
# 第42章 崩溃一致性：FSCK和日志
# 第43章 日志结构文件系统
# 第44章 数据完整性和保护
# 第47章 分布式系统
# 第48章 Sun的网络文件系统（NFS）
# 第49章 Andrew文件系统（AFS）